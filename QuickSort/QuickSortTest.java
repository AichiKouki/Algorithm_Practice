public class QuickSortTest {

  public static void main(String[] args) {
      int[] data = {5, 10, 3, 7, 8, 1, 9, 2};
      print_data(data);//ソート前の配列の中身を表示
      quick_sort(data, 0, data.length-1);//クイックソート処理。-1は、配列が0から始まる関係で-1している
      print_data(data);//クイックソートした後の配列の中身を表示
  }
    // 配列dのleftからrightまでの間のデータ列をクイックソートする
    //再帰処理が行われるので、一回交換処理を行うたびにこの関数は呼ばれる。
    static void quick_sort(int[] d, int left, int right) {//leftは0rightは7。分割するたびに変わるが、左の添え字と右の添え字
        if (left>=right) {//左側の添え字と右側の添え字で、右側以上になってしまったら処理しない
            return;
        }//5 2 3 「7」 8 1 9 10
        int p = d[(left+right)/2];//クイックソートで使う基準値を計算。今回は真ん中の数値を基準値にする。
        int l = left, r = right, tmp;//最新の左側の添え字と右側の添え字を格納する。
        while(l<=r) {//左側の添え字が右側よりちゃんと小さかったら処理。最初はlは0。rは7。ちなみに、ここのループは8回処理される
          //左側で大きい値と右側で小さい値を、見つかるまで探している
          //基準値より左に大きい値がなかったら、比較対象が基準値になった段階でl++が止まるから、交換する数値が基準値自信になる。
            while(d[l] < p) { l++; }//基準値から左側の、基準値より大きい値を探している。左側では左端から探すので、探している間はlを++する。
            while(d[r] > p) { r--; }//基準値から右側の、基準値より小さい値を探している。右側では右端から探すので、探している間はrを++する。
            if (l<=r) {//基準値から左にある大きい値の添え字が右にある小さい値の添え字より小さかったら、探した数値の交換処理を行う。(配列の左側の方が添え字が小さいのは通常の状態)
                tmp = d[l]; d[l] = d[r]; d[r] = tmp;//左側の大きい値と右側の小さい値を交換する処理
                l++; r--;//交換するたびに、次の交換処理を行うために、左側と右側の添え字を移動する。

                //配列の中身を確認
                for(int i=0;i<d.length;i++){
                  System.out.print(d[i]);
                }
                System.out.println("");
            }
        }
        //分割するたびに、また次の分割の処理をする。
        System.out.println("分割された左側の配列の左は"+left+"で右は"+r+"で、右側の配列の左は"+l+"で右は"+right);
        //再帰処理を繰り返して、どんどん分割する。
        quick_sort(d, left, r);  // ピボットより左側をクイックソート。上記の処理で交換した配列と、leftはクイックソートする前の左側の添え字で、rはクイックソートした後進んだ分の影響を受けている添え字
        quick_sort(d, l, right); // ピボットより右側をクイックソート。上記の処理で交換した配列と、rightはクイックソートする前の右側の添え字で、lはクイックソートした後進んだ文の影響を受けている添え字
    }
    // 配列内のデータ列を表示する
    static void print_data(int[] d) {
        for(int i = 0; i < d.length; i++) System.out.print(d[i] + " ");
        System.out.println();
    }
}
/*
データの集合を基準値より大きいものと小さいものとのグループに分け、
それぞれのグループの中でも新しい基準値を使って同様の作業を行う、という手順を再帰的に繰り返す方式。

基準値から左側では大きい値を探して(一番左端から)、右側では小さい値を探す(一番右端から)
5 10 3 「7」 8 1 9 2    　　　　最初の配列の状態
5 2 3 7 8 1 9 10　　　　　　1回目の交換した後の配列の状態。10と2を交換した
5 2 3 1 8 7 9 10　　　　　　2回めの交換した後の配列の状態。7と1を交換した。基準値より左に大きい値がなかったが、、比較対象が基準値まで進んだ段階でl++が止まるから、交換する数値が基準値自信になる。
分割された左側の配列の左は0で右は3で、右側の配列の左は4で右は7 　　　分割した後の、左側の配列の添え字と、右側の配列の添え字
1 2 3 5 8 7 9 10　　　　　　分割した後の
1 2 3 5 8 7 9 10
分割された左側の配列の左は0で右は0で、右側の配列の左は2で右は3
1 2 3 5 8 7 9 10
分割された左側の配列の左は2で右は1で、右側の配列の左は3で右は3
1 2 3 5 7 8 9 10
分割された左側の配列の左は4で右は4で、右側の配列の左は5で右は7
1 2 3 5 7 8 9 10
分割された左側の配列の左は5で右は5で、右側の配列の左は7で右は7
1 2 3 5 7 8 9 10

*/
